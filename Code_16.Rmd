---
title: "Glioma biomarkers to distinguish high-risk from low-risk patients"
author: "Beatriz Leitão and Susana Vinga"
date: "September, 2024"
output:
  html_document: 
    number_sections: yes
    toc: yes
editor_options:
  chunk_output_type: inline
---
# Install packages

```{r to_delete, results = 'hide', message=FALSE, warning=FALSE}
# # List of required packages
# required_packages <- c(
#   "lsa", "SnowballC", "propagate", "minpack.lm", "ff", "bit", "Rcpp", "tmvtnorm", "gmm",
#   "sandwich", "mvtnorm", "VennDiagram", "futile.logger",
#   "SIS", "survMisc", "risksetROC", "MASS", "survivalROC", "caTools", "pROC",
#   "writexl", "openxlsx", "caret", "lattice", "glmnet", "Matrix", "survminer", "ggpubr",
#   "survival", "DT", "lubridate", "forcats", "stringr", "purrr", "readr", "tidyr", "ggplot2",
#   "tidyverse", "tibble", "dplyr", "matrixStats", "grf", "randomForestSRC", "Boruta", "timeROC",
#   "qvalue"
# )
# 
# # Install missing packages
# installed_packages <- rownames(installed.packages())
# for (pkg in required_packages) {
#   if (!pkg %in% installed_packages) {
#     install.packages(pkg)
#   }
# }
# 
# # Load packages
# invisible(lapply(required_packages, require, character.only = TRUE))
# 
# # List of Bioconductor packages
# bioc_packages <- c(
#   "MultiAssayExperiment", "TCGAbiolinks", "SummarizedExperiment", "Biobase", 
#   "GenomicRanges", "GenomeInfoDb", "IRanges", "S4Vectors", "BiocGenerics", 
#   "MatrixGenerics", "matrixStats", "glmSparseNet", "MultiAssayExperiment",
#   "edgeR", "limma", "biomaRt", "TCGAbiolinks", "SummarizedExperiment", 
#   "Biobase", "GenomicRanges", "GenomeInfoDb", "IRanges", "S4Vectors", 
#   "BiocGenerics", "MatrixGenerics"
# )
# 
# # Install Bioconductor packages if not installed
# if (!requireNamespace("BiocManager", quietly = TRUE)) {
#   install.packages("BiocManager")
# }
# for (pkg in bioc_packages) {
#   if (!pkg %in% installed_packages) {
#     BiocManager::install(pkg)
#   }
# }
# 
# 
# # Load Bioconductor packages
# invisible(lapply(bioc_packages, require, character.only = TRUE))
# 
# # List of CRAN packages
# cran_packages <- setdiff(required_packages, bioc_packages)
# 
# # Install missing CRAN packages
# installed_packages <- rownames(installed.packages())
# for (pkg in cran_packages) {
#   if (!pkg %in% installed_packages) {
#     install.packages(pkg)
#   }
# }
# 
# # Load CRAN packages
# invisible(lapply(cran_packages, require, character.only = TRUE))
# 
# #renv::restore()
```

# Load libraries

```{r Load_libraries, results=FALSE, message=FALSE, warning=FALSE}

load_libraries <- function(...) {
  libs <- list(...)
  lapply(libs, require, character.only = TRUE)
}

invisible(load_libraries("TCGAbiolinks", "dplyr", "tibble", "tidyverse", "DT", "SummarizedExperiment", "survival", "survminer", "readr", "glmnet", "caret", "openxlsx", "biomaRt", "writexl", "edgeR", "pROC", "caTools", "survivalROC", "risksetROC", "lattice", "survMisc", "SIS", "VennDiagram", "glmSparseNet", "grf", "randomForestSRC", "Boruta", "timeROC", "qvalue", "survcomp"))

```

# Download functions

```{r Download_functions}

source("Functions/Data_preparation.R")
source("Functions/Model_evaluation.R")
source("Functions/Model_fitting.R")
source("Functions/Rank_product_test.R")

```

# Store results

```{r Store_results}

# Ensure the 'Results' directory exists
if (!dir.exists("Results")) {
  dir.create("Results")
}

```

# Download data

```{r Download_data, results = 'hide', message=FALSE, warning=FALSE}

query_RNA <- GDCquery(
  project = c("TCGA-GBM", "TCGA-LGG"),
  data.category = "Transcriptome Profiling",
  data.type = "Gene Expression Quantification",
  workflow.type = "STAR - Counts",
  experimental.strategy = ("RNA-Seq")
)
# Check if files exist before downloading
if (!dir.exists("GDCdata")) {
  GDCdownload(query = query_RNA)
}

TCGA_RNA <- GDCprepare(query = query_RNA)


```

# Prepare survival data

```{r Prepare_survival_data}
# Extract survival data of interest
columns_to_extract <- c("patient", "project_id", "vital_status", "days_to_death", "days_to_last_follow_up")
survival_data <- createSurvivalDataFrame(columns_to_extract, TCGA_RNA)


# Clean and prepare survival data
survival_data <- cleanSurvivalData(survival_data)
```

# Assign a new classification to the data

```{r Assign_new_classification_to_the_data, results = 'hide', message=FALSE, warning=FALSE}
# new classification -->
new_classification <- read_csv("SIMPLIFIED_CLASSIFICATION_TCGA_2016_2021.csv") #download the classification datafram
names(new_classification)[names(new_classification) == "Patient_ID"] <- "patient" # remane the Patient_ID column
new_classification <- subset(new_classification, select = -c(TCGA.histological.type, classification.2016)) # delete unnecessary columns

# Merge the dataframes to add the disease information keeping only common patients
survival_data <- merge(survival_data, new_classification, by = "patient")
survival_data <- subset(survival_data, select = -project_id) # remove old classification
names(survival_data)[names(survival_data) == "classification.2021"] <- "project_id" # aplly the old name to the new classification

```

# Select and prepare expression data

```{r Select_and_prepare_expression_data}
# Extrair dataframe com a expressão dos genes de interesse
genes_expression <- createGeneExpressionDataframe("protein_coding", "unstranded", TCGA_RNA, survival_data)
#genes_expression <- createGeneExpressionDataframe("lncRNA", "unstranded", TCGA_RNA, survival_data)
#genes_expression <- createGeneExpressionDataframe("miRNA", "unstranded", TCGA_RNA, survival_data)       #<------------ indicar os dados 

# Clean the gene expression dataframe
genes_expression <- cleanGeneExpressionData(genes_expression)
```

# Disease selection and data normalization

```{r Disease_selection_and_data_normalization}

#------------ OLD CLASSIFICATION-------------------------------------------------

# selecionar apenas os dados da doença de interesse
#data <- selectDataPerDisease("TCGA-GBM", genes_expression, survival_data)
#data <- selectDataPerDisease("TCGA-LGG", genes_expression, survival_data)                                   

#------------ NEW CLASSIFICATION-------------------------------------------------

#data <- selectDataPerDisease("astrocytoma", genes_expression, survival_data)
data <- selectDataPerDisease("glioblastoma", genes_expression, survival_data)
#data <- selectDataPerDisease("oligodendroglioma", genes_expression, survival_data)

genes_expression <- data$genes_expression
survival_data <- data$survival_data

# remove genes where the sum of the gene expression is 0 (necessary to repeat this step, since there is a selection of patients) 
genes_expression <- cleanGeneExpressionData(genes_expression)

# EdgeR+voom normalization
genes_expression <- normalizationEdgeR(genes_expression)

# Clean the gene expression dataframe
genes_expression <- cleanGeneExpressionData(genes_expression)

# ordenar os dados por paciente
genes_expression <- orderDataByPatient(genes_expression)
survival_data <- orderDataByPatient(survival_data)

```

# Find the best alpha for Regularized Cox Regression model glmnet

```{r Find_the_best_alpha_for_Regularized_Cox_Regression, message=FALSE, warning=FALSE}

# indicate the alpha values to test
alpha_vector <- seq(0.1, 1, by = 0.1) # if alpha is set to zero (ridge regression), the coxph model will give the Error: protect(): protection stack overflow

# List of seed values
seed_values <- seq(1000, 1100, by = 50)

# evaluate the alpha values through multiple seeds
results_df <- find_best_alpha_for_glmnet(alpha_vector, seed_values, genes_expression, survival_data)

# select the best alpha
best_alpha <- results_df$Alpha[which.max(results_df$Average_C_Index)]

results_df
cat("Best alpha: ", "\n", best_alpha, "\n")
```

# Fit and Explore the Models

```{r Fit_and_Explore_the_Models, message=FALSE, warning=FALSE}

# Models' names
models_names_list <- c("GLMNET_Coefficients", "SIS_Coefficients", "ISIS_Coefficients", "RandomForest_Coefficients", "CausalForest_Coefficients", "Boruta_Coefficients")

# Define the seeds for 3 iterations
seeds <- seq(1000, 1100, by = 50)

# Initialize a list to store the coefficients for each iteration
models_coefficients_list <- list()

# Create an empty dataframe to store C-index values
num_models <- length(models_names_list) # Assuming each iteration has the same number of models
c_index_df <- data.frame(matrix(ncol = length(seeds), nrow = num_models))
colnames(c_index_df) <- paste0("Seed_", seeds)
rownames(c_index_df) <- models_names_list

# Create an empty dataframe to store the number of coefficients
num_coeff_df <- data.frame(matrix(ncol = length(seeds), nrow = num_models))
colnames(num_coeff_df) <- paste0("Seed_", seeds)
rownames(num_coeff_df) <- models_names_list


# Loop through the seeds and run the analysis
for (i in seq_along(seeds)) {
  
  set.seed(i)
  # Split the data
  splited <- splitTestAndTrain(genes_expression, survival_data, 0.7)
  
  genes_expression_train <- splited$expression_train
  survival_train <- splited$survival_train
  genes_expression_test <- splited$expression_test
  survival_test <- splited$survival_test
  
  # Define survival object
  survival_object_train <- Surv(time = survival_train$days, event = survival_train$vital_status)
  
  # Fit models
  models_coefficients_list[[i]] <- fit_models(genes_expression_train, survival_object_train, best_alpha, survival_train)
  
  # Calculate and store C-index for each model
  
  for (j in seq_along(models_coefficients_list[[i]])) {
    
    num_coeff_df[j, i] <- length(models_coefficients_list[[i]][[j]]$ensembl_gene_id)
    
    if (num_coeff_df[j, i] > 0) {
      
      c_index_df[j, i] <- calculate_c_index(survival_object_train, genes_expression_train, models_coefficients_list[[i]][[j]], genes_expression_test, survival_test, survival_data)
      
      num_coeff_df[j, i] <- length(models_coefficients_list[[i]][[j]]$ensembl_gene_id)
    } else {
      
      # If the model has empty coefficients, set C-index to NA 
      c_index_df[j, i] <- NA
           }
    }
}

# Create a summary table
summary_table <- data.frame(
  Model = models_names_list,
  C_Index_Avg = round(apply(c_index_df, 1, mean, na.rm = TRUE), 3),
  C_Index_Std_Dev = round(apply(c_index_df, 1, sd, na.rm = TRUE), 3),
  Coeff_Num_Avg = round(apply(num_coeff_df, 1, mean), 1),
  Coeff_Num_Std_Dev = round(apply(num_coeff_df, 1, sd), 1),
  Non_Convergence_Perc = apply(num_coeff_df, 1, function(x) mean(x == 0) * 100)
)

#Save a summary table as a CSV file
write.csv(summary_table, file = "Results/summary_table.csv", row.names = FALSE)

print(summary_table)

```

# Indentify oultiers with the rank product test

```{r Indentify_oultiers_with_the_rank_product_test, message=FALSE, warning=FALSE}

# Calculate martingale residuals for each model
martingale_residuals_matrix <- calculate_martingale_residuals(models_coefficients_list, genes_expression, survival_data)

rank_product_results <- calculate_rank_product(martingale_residuals_matrix)

# p-values calculation

rho = rank_product_results #rank product matrix result
n <-dim(survival_data)[1] # number of samples
k <-sum(sapply(unlist(models_coefficients_list, recursive = FALSE), function(df) nrow(df) > 0)) # number of models with coefficients different than zero

pvalues <- as.vector(rankprodbounds(rho,n,k,Delta ='geometric')) # The p-values are obtained by the following, where Delta option is the geometric mean.

# Ensure all p-values are within the [0, 1] range: Even though the values should be in this range, sometimes very small floating-point errors can cause issues
pvalues <- pmin(pmax(pvalues, 0), 1)

# q-values calculation
qobj<-qvalue(pvalues)
qvalues<-qobj$qvalues
outliers_rank_product <- which(qvalues<0.001) # Tightened the significance threshold to q-values < 0.001, instead of 0.05, to focus on the most significant outliers, reducing the number of outliers for more robust model evaluation.

# Remove the rows corresponding to outliers 
genes_expression_without_outliers <- genes_expression[-outliers_rank_product, ]
survival_data_without_outliers <- survival_data[-outliers_rank_product, ]

## Kaplan-Meier Curves for Both Before and After Outlier Removal

# Combine the datasets and create the grouping variable
combined_survival_data <- rbind(
  data.frame(survival_data, group = "With Outliers"),
  data.frame(survival_data_without_outliers, group = "Without Outliers")
)

# Fit Kaplan-Meier survival model using the combined dataset
fit_km_before_after <- survfit(Surv(days, vital_status) ~ group, data = combined_survival_data)
survdiff(Surv(days, vital_status) ~ group, data = combined_survival_data)

# Create a combined Kaplan-Meier plot with both before and after curves
km_before_after <- ggsurvplot(fit_km_before_after,
                              data = combined_survival_data,
                              title = "Kaplan-Meier Curves Pre and Post Outlier Removal",
                              xlab = "Time (days)",
                              ylab = "Survival Probability",
                              legend.title = "Group",
                              risk.table = TRUE
                              )

km_before_after$plot

survdiff_km_before_after_output <- capture.output(survdiff(Surv(days, vital_status) ~ group, data = combined_survival_data))

# # Grouping data by outliers
# survival_data$group <- ifelse(rownames(survival_data) %in% outliers_rank_product, "Outlier", "Non-Outlier")
# 
# # Kaplan-Meier survival curves
# fit_km <- survfit(Surv(days, vital_status) ~ group, data = survival_data)
# plot_outliers <- ggsurvplot(fit_km, data = survival_data, pval = TRUE, risk.table = TRUE,
#            title = "Kaplan-Meier Curves by Outlier Status",
#            legend.title = "Group")
# plot_outliers$plot
# 
# 
# survdiff(Surv(survival_data$days, survival_data$vital_status) ~ survival_data$group)
# survdiff_outliers_output <- capture.output(survdiff(Surv(survival_data$days, survival_data$vital_status) ~ survival_data$group))


# Create the table with the specified information
outliers_table <- data.frame(
  Index = outliers_rank_product,
  Time = survival_data$days[outliers_rank_product],
  Status = survival_data$vital_status[outliers_rank_product],
  p_value = pvalues[outliers_rank_product],
  q_value = qvalues[outliers_rank_product]
)

# Order the table by q-value
outliers_table <- outliers_table[order(outliers_table$q_value), ]

# Print the table to check
print(outliers_table)


# Write the captured output to a file
writeLines(survdiff_km_before_after_output, "Results/survdiff_Before_After_Outliers_Removal.txt")

# Save plot
ggsave(filename = "Results/KM_Curve_Before_After_Outliers_Removal.pdf", plot = km_before_after$plot, width = 6, height = 4)

# Save the table as a CSV file in the "Results" directory
write.csv(outliers_table, file = "Results/outliers_table.csv", row.names = FALSE)

```
# Fit and Explore the Models Without Outliers

```{r Fit_and_Explore_the_Models_Without_Outliers, message=FALSE, warning=FALSE}

# Initialize a list to store the coefficients for each iteration
models_coefficients_list_without_outliers <- list()

# Create an empty dataframe to store C-index values
num_models <- length(models_names_list) # Assuming each iteration has the same number of models
c_index_df_without_outliers <- data.frame(matrix(ncol = length(seeds), nrow = num_models))
colnames(c_index_df_without_outliers) <- paste0("Seed_", seeds)
rownames(c_index_df_without_outliers) <- models_names_list

# Create an empty dataframe to store the number of coefficients
num_coeff_df_without_outliers <- data.frame(matrix(ncol = length(seeds), nrow = num_models))
colnames(num_coeff_df_without_outliers) <- paste0("Seed_", seeds)
rownames(num_coeff_df_without_outliers) <- models_names_list


# Loop through the seeds and run the analysis
for (i in seq_along(seeds)) {
  cat("Running analysis for seed:", seeds[i], "\n")
  
  # Split the data
  set.seed(i)
  splited <- splitTestAndTrain(genes_expression_without_outliers, survival_data_without_outliers, 0.7)
  
  genes_expression_train <- splited$expression_train
  survival_train <- splited$survival_train
  genes_expression_test <- splited$expression_test
  survival_test <- splited$survival_test
  
  # Define survival object
  survival_object_train <- Surv(time = survival_train$days, event = survival_train$vital_status)
  
  # Fit models
  models_coefficients_list_without_outliers[[i]] <- fit_models(genes_expression_train, survival_object_train, best_alpha, survival_train)
  
  # Calculate and store C-index for each model
  
  for (j in seq_along(models_coefficients_list_without_outliers[[i]])) {
    
    num_coeff_df_without_outliers[j, i] <- length(models_coefficients_list_without_outliers[[i]][[j]]$ensembl_gene_id)
    
    if (num_coeff_df_without_outliers[j, i] > 0) {
      
      c_index_df_without_outliers[j, i] <- calculate_c_index(survival_object_train, genes_expression_train, models_coefficients_list_without_outliers[[i]][[j]], genes_expression_test, survival_test, survival_data)
      
      num_coeff_df_without_outliers[j, i] <- length(models_coefficients_list_without_outliers[[i]][[j]]$ensembl_gene_id)
    } else {
      # If the model has empty coefficients, set C-index to NA 
      c_index_df_without_outliers[j, i] <- NA
           }
    }
}

# Create a summary table
summary_table_without_outliers <- data.frame(
  Model = models_names_list,
  C_Index_Avg = round(apply(c_index_df_without_outliers, 1, mean, na.rm = TRUE), 3),
  C_Index_Std_Dev = round(apply(c_index_df_without_outliers, 1, sd, na.rm = TRUE), 3),
  Coeff_Num_Avg = round(apply(num_coeff_df_without_outliers, 1, mean), 1),
  Coeff_Num_Std_Dev = round(apply(num_coeff_df_without_outliers, 1, sd), 1),
  Non_Convergence_Perc = apply(num_coeff_df_without_outliers, 1, function(x) mean(x == 0) * 100)
)

# Save a summary table as a CSV file
write.csv(summary_table_without_outliers, file = "Results/summary_table_without_outliers.csv", row.names = FALSE)

print(summary_table_without_outliers)
```
# Analyse the best model

```{r Analyse_the_best_model, message=FALSE, warning=FALSE}
# Identify the model with the highest average C-index
best_model_index <- which.max(rowMeans(c_index_df_without_outliers, na.rm = TRUE))
best_model_name <- rownames(c_index_df_without_outliers)[best_model_index]

cat("Best model:", best_model_name, "\n")

# Get the coefficients of the best model
best_model_coefficients <- models_coefficients_list[[1]][[best_model_index]] # o index aqui escolhido tem que bater certo com o seed do split data para que dê igual performance

# Get information on the coefficients of the best model    
gene_info_result <- getGenesInfo(best_model_coefficients)
print(gene_info_result)

set.seed(1000)
# Split the data
splited <- splitTestAndTrain(genes_expression_without_outliers, survival_data_without_outliers, 0.7)
  
genes_expression_train <- splited$expression_train
survival_train <- splited$survival_train
genes_expression_test <- splited$expression_test
survival_test <- splited$survival_test
  
# Define survival object
survival_object_train <- Surv(time = survival_train$days, event = survival_train$vital_status)

# Fit a Cox regression model using the covariates
fit <- coxph(survival_object_train ~ ., 
             data = subset(genes_expression_train, select = best_model_coefficients$ensembl_gene_id), # specify coefficients 
             init = as.numeric(best_model_coefficients$Coef_value), # specify coefficient values
             iter.max = 0) # force the software to keep those values

# Test the proportional hazards assumption for a Cox regression model fit (coxph)
Propo_hazards <- cox.zph(fit, transform="km", terms=TRUE, singledf=FALSE, global=TRUE)
Propo_hazards_global_p_value <- Propo_hazards$table["GLOBAL", "p"]
print(Propo_hazards$table)

# Construct a risk score based on the linear predictor on the test data
survival_probabilities_test <- predict(fit, newdata = subset(genes_expression_test, select = best_model_coefficients$ensembl_gene_id), type = "lp")

#---------------------------- AUC


# Calculate AUC at specific time points with a specified span
times <- c(1, 3, 5)
n_events <- sum(survival_test$vital_status)
span <- 0.25 * n_events^(-0.20) # equal to package developers span

auc_values <- sapply(times, function(t) {
  roc_result <- survivalROC(Stime = survival_test$days,
                            status = survival_test$vital_status,
                            marker = survival_probabilities_test,
                            predict.time = t * 365.25,
                            method = "NNE",
                            span = span)
  roc_result$AUC
})

auc_df <- data.frame(Time = times, AUC = round(auc_values, 3))
print(auc_df)


#---------------------------- Cumulative case/dynamic control ROC, fonte: https://datascienceplus.com/time-dependent-roc-for-survival-prediction-models-in-r/
# The cumulative sensitivity considers those who have died by time t
# The dynamic specificity regards those who are still alive at time t 
# This is one gives the prediction performance for the risk (cumulative incidence) of events over the t-year period.
Cumulative_ROC <- CumulativeCaseDynamicControlROC(survival_test, survival_probabilities_test, "Cumulative case/ Dynamic control ROC")
Cumulative_ROC

#---------------------------- Incident case/dynamic control ROC, fonte: https://datascienceplus.com/time-dependent-roc-for-survival-prediction-models-in-r/
# The incident sensitivity considers those who die at time t
# The dynamic specificity regards those who are still alive at time t 
# This one gives the prediction performance for the hazard (incidence in the risk set) of events at t-year among those who are in the risk set at t.
Incident_ROC <-IncidentCaseDynamicControlROC(survival_test, survival_probabilities_test, "Incident case/ Dynamic control ROC")
Incident_ROC

#Risk AUC based on Incident case/dynamic control
riskAUC = risksetAUC(Stime=survival_test$days,
                       status = survival_test$vital_status,
                       marker = survival_probabilities_test,
                       method = "Cox",
                       tmax = ceiling(max(survival_data$days)),
                       plot = TRUE)


# Construct a risk score based on the linear predictor on the train data
survival_probabilities_train <- predict(fit, newdata = subset(genes_expression_train, select = best_model_coefficients$ensembl_gene_id), type = "lp")

# Categorize individuals of the test data based on the median
risk <- ifelse(survival_probabilities_test > median(survival_probabilities_test), "High", "Low")

# Kaplan-Meier com a separação por High/ Low
fit_surv <- survfit(Surv(survival_test$days, survival_test$vital_status) ~ risk)
survdiff(Surv(survival_test$days, survival_test$vital_status) ~ risk)

survdiff_output <- capture.output(survdiff(Surv(survival_test$days, survival_test$vital_status) ~ risk))
plot <- ggsurvplot(fit_surv, 
                   data = survival_test, 
                   title = "Kaplan-Meier Curves by Risk Status",
                   xlab = "Time (days)",
                   legend.title = "Group")
plot$plot


# Save a predictors genes and coefficients as a CSV file
write.csv(Propo_hazards$table, file = "Results/Propo_hazards", row.names = TRUE)

# Save a predictors genes and coefficients as a CSV file
write.csv(gene_info_result, file = "Results/predictors_genes_and_coefficients", row.names = FALSE)

# Write the captured output to a file
writeLines(survdiff_output, "Results/survdiff_output.txt")

# Save plots
ggsave(filename = "Results/plot_high_low_risk.pdf", plot = plot$plot, width = 6, height = 4)
ggsave(filename = "Results/Cumulative_ROC.pdf", plot = Cumulative_ROC, width = 6, height = 4)
ggsave(filename = "Results/Incident_ROC.pdf", plot = Incident_ROC, width = 6, height = 4)

# Save a AUC 1, 3, and 5 years as a CSV file
write.csv(auc_df, file = "Results/AUC_1_3_5", row.names = FALSE)

```

# Analyse the balance of censored data in test and training

```{r Analyse_the_balance_of_censored_data_in_test_and_training}

counts_test <- table(survival_test$vital_status)

# Calculate the percentage of zeros and ones
test_percent_zeros <- round((counts_test[1] / sum(counts_test)) * 100, 2)
test_percent_ones <- round((counts_test[2] / sum(counts_test)) * 100, 2)

counts_train <- table(survival_train$vital_status)

# Calculate the percentage of zeros and ones
train_percent_zeros <- round((counts_train[1] / sum(counts_train)) * 100, 2)
train_percent_ones <- round((counts_train[2] / sum(counts_train)) * 100, 2)

# Create a dataframe to store the comparison
comparison_test_train_data <- data.frame(
  Dataframe = c("survival_test", "survival_train"),
  Alive = c(test_percent_zeros, train_percent_zeros),
  Dead = c(test_percent_ones, train_percent_ones)
)

comparison_test_train_data

# Save the table as a CSV file in the "Results" directory
write.csv(comparison_test_train_data, file = "Results/comparison_test_train_data.csv", row.names = FALSE)

```

# Test the best model on the train data

```{r Test_the_best_model_on_the_train_data}

# Construct a risk score based on the linear predictor on the train data
a_survival_probabilities_train <- predict(fit, newdata = subset(genes_expression_train, select = best_model_coefficients$ensembl_gene_id), type = "lp")

# Categorize individuals of the test data based on the median
risk_groups <- ifelse(a_survival_probabilities_train > median(a_survival_probabilities_train), "High", "Low")

# Kaplan-Meier com a separação por High/ Low
fit_surv <- survfit(Surv(survival_train$days, survival_train$vital_status) ~ risk_groups)
survdiff(Surv(survival_train$days, survival_train$vital_status) ~ risk_groups)
survdiff_output_train_data <- capture.output(survdiff(Surv(survival_train$days, survival_train$vital_status) ~ risk_groups))

plot_train_data <- ggsurvplot(fit_surv, data = survival_train, title = "Kaplan-Meier Curves by Risk Status (train data)", legend.title = "Group")
plot_train_data$plot


# Write the captured output to a file
writeLines(survdiff_output_train_data, "Results/survdiff_output_train_data.txt")

# Save plot
ggsave(filename = "Results/plot_high_low_risk_train_data.pdf", plot = plot_train_data$plot, width = 6, height = 4)

```
