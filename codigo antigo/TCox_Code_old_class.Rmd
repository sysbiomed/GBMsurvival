---
title: "Glioma biomarkers (astrocytoma and gliobastoma) to distinguish high-risk from low-risk patients"
author: "Beatriz Leitão and Susana Vinga"
date: "May, 2024"
output:
  html_document: 
    number_sections: yes
    toc: yes
params:
  seed: !r 3390
  train: !r 0.7
  nfolds: !r 10
editor_options:
  chunk_output_type: inline
---
# Install packages

```{r}

# List of required packages
required_packages <- c(
  "lsa", "SnowballC", "propagate", "minpack.lm", "ff", "bit", "Rcpp", "tmvtnorm", "gmm",
  "sandwich", "mvtnorm", "glmSparseNet", "MultiAssayExperiment", "VennDiagram", "futile.logger",
  "SIS", "survMisc", "risksetROC", "MASS", "survivalROC", "caTools", "pROC", "edgeR", "limma",
  "writexl", "biomaRt", "openxlsx", "caret", "lattice", "glmnet", "survminer", "ggpubr",
  "survival", "DT", "lubridate", "forcats", "stringr", "purrr", "readr", "tidyr", "ggplot2",
  "tidyverse", "tibble", "dplyr", "TCGAbiolinks", "SummarizedExperiment", "Biobase", "GenomicRanges",
  "GenomeInfoDb", "IRanges", "S4Vectors", "BiocGenerics", "MatrixGenerics", "matrixStats"
)

if (!requireNamespace("BiocManager", quietly = TRUE)) {
install.packages("BiocManager")
}

# Remove any old version of Matrix package
if ("Matrix" %in% installed.packages()) {
  remove.packages("Matrix")
}

# Install the correct version of Matrix package from source
install.packages("https://cran.r-project.org/src/contrib/Archive/Matrix/Matrix_1.6-0.tar.gz", repos = NULL, type = "source")


# Install missing packages
installed_packages <- rownames(installed.packages())
for (pkg in required_packages) {
if (!pkg %in% installed_packages) {
install.packages(pkg)
}
}

# List of required packages
required_packages <- c(
"lsa", "SnowballC", "propagate", "minpack.lm", "ff", "bit", "Rcpp", "tmvtnorm", "gmm",
"sandwich", "mvtnorm", "glmSparseNet", "MultiAssayExperiment", "VennDiagram", "futile.logger",
"SIS", "survMisc", "risksetROC", "MASS", "survivalROC", "caTools", "pROC", "edgeR", "limma",
"writexl", "biomaRt", "openxlsx", "caret", "lattice", "glmnet", "Matrix", "survminer", "ggpubr",
"survival", "DT", "lubridate", "forcats", "stringr", "purrr", "readr", "tidyr", "ggplot2",
"tidyverse", "tibble", "dplyr", "TCGAbiolinks", "SummarizedExperiment", "Biobase", "GenomicRanges",
"GenomeInfoDb", "IRanges", "S4Vectors", "BiocGenerics", "MatrixGenerics", "matrixStats"
)
# Ensure BiocManager is installed
if (!requireNamespace("BiocManager", quietly = TRUE)) {
install.packages("BiocManager")
}
# Remove any old version of Matrix package
if ("Matrix" %in% installed.packages()) {
remove.packages("Matrix")
}
# Install the correct version of Matrix package from source
install.packages("https://cran.r-project.org/src/contrib/Archive/Matrix/Matrix_1.6-0.tar.gz", repos = NULL, type = "source")

# Install missing packages
installed_packages <- rownames(installed.packages())
for (pkg in required_packages) {
if (!pkg %in% installed_packages) {
install.packages(pkg)
}
}
# Load packages
invisible(lapply(required_packages, require, character.only = TRUE))
# List of Bioconductor packages
bioc_packages <- c(
"MultiAssayExperiment", "TCGAbiolinks", "SummarizedExperiment", "Biobase",
"GenomicRanges", "GenomeInfoDb", "IRanges", "S4Vectors", "BiocGenerics",
"MatrixGenerics", "matrixStats"
)
# Install Bioconductor packages if not installed
if (!requireNamespace("BiocManager", quietly = TRUE)) {
install.packages("BiocManager")
}
for (pkg in bioc_packages) {
if (!pkg %in% installed_packages) {
BiocManager::install(pkg)
}
}
# Load Bioconductor packages
invisible(lapply(bioc_packages, require, character.only = TRUE))
# List of CRAN packages
cran_packages <- setdiff(required_packages, bioc_packages)
# Install missing CRAN packages
installed_packages <- rownames(installed.packages())
for (pkg in cran_packages) {
if (!pkg %in% installed_packages) {
install.packages(pkg)
}
}
# Load CRAN packages
invisible(lapply(cran_packages, require, character.only = TRUE))
# Finally, install quantreg package
if (!"quantreg" %in% installed.packages()) {
install.packages("quantreg")
}

```

# Required libraries

```{r message = FALSE}
library(TCGAbiolinks)
library(dplyr)
library(tibble)
library(tidyverse)
library(DT)
library(SummarizedExperiment)
library(survival)
library(survminer)
library(readr)
library(glmnet)
library(caret)
library(openxlsx)
library(biomaRt)
library(writexl)
library(edgeR)
library(pROC)
library(caTools)
library(survivalROC)
library(risksetROC)
library(lattice)
library(survMisc)
library(SIS)
library(VennDiagram)
library(glmSparseNet)
```

# Functions definition

## Prepare survival data

```{r}
# Extract survival data of interest
createSurvivalDataFrame <- function(column_names, source_data) {
  
  data_frame <- data.frame(matrix(ncol = length(column_names), nrow = nrow(source_data@colData)))
  colnames(data_frame) <- column_names

  for (col_name in column_names) {
    # Extract the column from the source and add it to the dataframe
    data_frame[[col_name]] <- source_data@colData@listData[[col_name]]
  }

  return(data_frame)
}

# Clean and prepare survival data
cleanSurvivalData <- function(data) {
  
  # apagar as linhas que têm NA no vital status
  data <- data[complete.cases(data$vital_status), ]
  
  # apagar as linhas que têm Not reported no vital status
  data <- data[data$vital_status != "Not Reported", ]
  
  # alterar o vital_status para 1 em caso de Dead e 0 se Alive
  data <- data %>%
    mutate(vital_status = ifelse(vital_status == "Alive",0,1))
  
  # criar a coluna days, assumindo os dias até à morte em caso de Dead e os dias até ao último follow up em caso de Alive
  data <- data %>% mutate(
    days = case_when(
      data$vital_status == 1 ~ data$days_to_death,
      data$vital_status == 0 ~ data$days_to_last_follow_up
    )
  )
  
  # apagar as linhas que têm NA no days
  data <- data[complete.cases(data$days), ]
  
  # deixar apenas as linhas que têm valores positivos no days
  data <- data[data$days > 0, ]
   
  # Keep only distinct rows based on the "patient" column
  data <- distinct(data, patient, .keep_all = TRUE)
  
  return(data)
}
```

## Prepare gene expression data

```{r}
# Extrair dataframe com a expressão dos genes de interesse
createGeneExpressionDataframe <- function(genes_of_interest, expression_measure, source_data, survivalData) {
  
  
  genes_table <- as.data.frame(source_data@rowRanges@elementMetadata@listData) # Tranformar a informação sobre os genes numa dataframe
  genes_table <- genes_table[genes_table$gene_type == genes_of_interest, ] #selecionar os genes de interesse
  
  expression_data <- as.data.frame(source_data@assays@data@listData[[expression_measure]]) #dataframe com a expressão de todos os genes
  colnames(expression_data) <- source_data@colData@listData[["patient"]] # adicionar os barcodes ao dataframe
  expression_data <- expression_data[, !duplicated(names(expression_data))] #remover individuos em duplicado
  rownames(expression_data) <- source_data@rowRanges@elementMetadata@listData$gene_id # adicionar o nome dos genes ao dataframe
  expression_data <- expression_data[,colnames(expression_data) %in% survivalData$patient] # selecionar apenas os individuos dos quais temos informação sobre sobrevivência
  expression_data <- as.data.frame(t(expression_data)) #transpor a dataframe
  
  data_frame <- expression_data[, colnames(expression_data) %in% genes_table$gene_id] #seleciinar a expressão dos genes de interesse
  
  return(data_frame)
}

# Clean the gene expression dataframe
cleanGeneExpressionData <- function(expression_data) {
  
  # Check if "patient" column exists in the dataframe
  if ("patient" %in% colnames(expression_data)) {
    # If "patient" column exists, use function #1
    rownames(expression_data) <- expression_data$patient # transform patients column in rowsnames
    expression_data <- expression_data[, -1] # delete the column patients 
    expression_data <- expression_data[, colSums(expression_data) != 0] #remove genes where all expression values are 0
    expression_data <- expression_data[rowSums(expression_data) != 0, ] #remove samples where the sum of the gene expression is 0
    expression_data <- expression_data %>% rownames_to_column(var = "patient") # transform row names into a column again
  } else {
    # If "patient" column doesn't exist, use function #2
    expression_data <- expression_data[, colSums(expression_data) != 0] #remove genes where all expression values are 0
    expression_data <- expression_data[rowSums(expression_data) != 0, ] #remove samples where the sum of the gene expression is 0
    expression_data <- expression_data %>% rownames_to_column(var = "patient") # transform row names into a column
    
  }
  
  return(expression_data)
}
```

## Select the disease and normalize the data

```{r}
# selecionar apenas os dados da doença de interesse
selectDataPerDisease <- function(disease, expression_data, survivalData) {
  
  #survival data
  survivalData <- survivalData[survivalData$project_id == disease, ] # select the survival data from the patients with the disease
  survivalData <- survivalData[, c('patient', 'vital_status', 'days')] # keep only the columns of interest
  #expression data
  merged_data <- merge(survivalData, expression_data, by = "patient") # select only the patients from the gene expression dataframe with the desired disease and select only the patients whose the sum of the gene expression is not zero
  expression_data <- merged_data[, c(-2,-3)] # delete the columns added above
  
  result <- list(survival_data = survivalData, genes_expression = expression_data)
  
  return(result)
}

# EdgeR normalization
normalizationEdgeR <- function(data) { 
  
  patients_IDs <- data[, 1]
  genes_expression <- t(data[, -1])
  dge <- DGEList(counts = genes_expression)
  dge <- normLibSizes(dge, method = "TMM")
  
  # usando cpm
  #normcounts <- cpm(dge)
  
  # usando o voom
  y <- voom(dge, plot=T)
  lognormcounts <- as.data.frame(y$E)
  normcounts <- as.data.frame(2^lognormcounts)
  
  genes_expression <- t(normcounts)
  genes_expression <- as.data.frame(genes_expression)
  rownames(genes_expression) <- NULL
  genes_expression <- cbind(patient = patients_IDs, genes_expression)

  return(genes_expression)
}

# ordenar os dados por paciente
orderDataByPatient <- function(data) {
  
  data <- data[order(data$patient), ]
  
  return(data)
}

# create a dataframe with categorized gene expression (high and low)
categorizeGeneExpressionData <- function(expression_data) {
  
  categorized_expression_data <- data.frame(patient = expression_data$patient) # Create a data frame for categorized gene expression
  genes_list <- colnames(expression_data[,-1]) #create a list of genes
  
  # Loop through each gene and categorize based on the median
  for (gene in genes_list) {
    # Calculate the median expression for the gene
    median_expression <- median(expression_data[[gene]])
    
    # Create a grouping variable for the gene based on the median
    categorized_expression_data[[gene]] <- ifelse(expression_data[[gene]] > median_expression, "high", "low")
  }
  
  return(categorized_expression_data)
}
```

## Split the data in train and test

```{r}
splitTestAndTrain <- function(expression, survival, percentage) { 
  
  merged_data <- merge(survival, expression, by = "patient")
  
  # creating a sample diving into the ratio defined 
  sample <- sample.split(merged_data$patient, SplitRatio = percentage)
  
  # creating training dataset 
  train_data  <- subset(merged_data, sample == TRUE) 
  
  # creating testing dataset 
  test_data <- subset(merged_data, sample == FALSE) 
  
  # Separate survival from expression
  survival_train <- train_data[, c(1:3)]
  survival_test <- test_data[, c(1:3)]
  expression_train <- train_data[, -c(2:3)]
  expression_test <- test_data[, -c(2:3)]
  
  result <- list(survival_train = survival_train, survival_test = survival_test,
                 expression_train = expression_train, expression_test = expression_test)
  
  return(result)
}
```

## Regularized Cox Regression functions

```{r}
#preparar os dados para a Regularized Cox Regression
prepareDataForCoxRegression <- function(data) { 
  
  rownames(data) <- data$patient
  data <- data[, -1]
  data <- data.matrix(data)
  
  return(data)
}

# Extract coefficients from the fitted model
extractCoxRegressionCoefficients <- function(cox_fit) { 

  coefficients <- data.frame(as.matrix(coef(cox_fit, s = "lambda.min")))  # Choose the lambda that minimizes cross-validated error
  colnames(coefficients)[colnames(coefficients) == 'X1'] <- "Coef_value" # Change the column name 
  coefficients <- subset(coefficients, Coef_value != 0) # select only the coefficients that are not equal to zero
  #rownames(coefficients) <- sub("\\..*", "", rownames(coefficients)) # Remove the version of the gene from its name(everything after the dot including the dot)
  coefficients$ensembl_gene_id <- rownames(coefficients)
  rownames(coefficients) <- NULL
  
  # Print min lambda
  #cat("Lambda min:", "\n", cox_fit$lambda.min)

  return(coefficients)
}

```

## Get Information about the genes whose coefficient is not zero

```{r}
# Function to get gene information
getGenesInfo <- function(coefficients) {
  
  # Remove the version of the gene from its name(everything after the dot including the dot)
  coefficients$ensembl_gene_id <- sub("\\..*", "", coefficients$ensembl_gene_id) 
  
  # Connect to the Ensembl database
  #ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
  ensembl <- useEnsembl(biomart = "ensembl", dataset = "hsapiens_gene_ensembl") #mirror = "www")
    # Get information about the genes
  gene_info <- getBM(attributes = c("ensembl_gene_id", "external_gene_name", "description"),
                     filters = "ensembl_gene_id",
                     values = coefficients$ensembl_gene_id,
                     mart = ensembl)
  
  # Merge gene coefficents and gene information
  gene_info <- merge(coefficients, gene_info, by = "ensembl_gene_id")
  gene_info <- gene_info[order(-abs(gene_info$Coef_value)), ]
  
  print(gene_info)
  
  return(gene_info)
}
```

## Cumulative case/dynamic control ROC

```{r}
# fonte: https://datascienceplus.com/time-dependent-roc-for-survival-prediction-models-in-r/
# The cumulative sensitivity considers those who have died by time t
# The dynamic specificity regards those who are still alive at time t 
# This is one gives the prediction performance for the risk (cumulative incidence) of events over the t-year period.

CumulativeCaseDynamicControlROC <- function(survival_data, survival_probabilities) {
  
  ## Define a helper function to evaluate at various t
  survivalROC_helper <- function(t) {
    survivalROC(Stime        = survival_data$days,
                status       = survival_data$vital_status,
                marker       = survival_probabilities,
                predict.time = t,
                method       = "NNE",
                span = 0.25 * nrow(survival_data)^(-0.20))
  }
  ## Evaluate every X days
  survivalROC_data <- data_frame(t = ceiling(max(survival_data$days)/6) * c(1,2,3,4,5,6)) %>%
    mutate(survivalROC = map(t, survivalROC_helper),
           ## Extract scalar AUC
           auc = map_dbl(survivalROC, magrittr::extract2, "AUC"),
           ## Put cut off dependent values in a data_frame
           df_survivalROC = map(survivalROC, function(obj) {
             as_data_frame(obj[c("cut.values","TP","FP")])
           })) %>%
    dplyr::select(-survivalROC) %>%
    unnest() %>%
    arrange(t, FP, TP)
  ## Plot
  survivalROC_data %>%
    ggplot(mapping = aes(x = FP, y = TP)) +
    geom_point() +
    geom_line() +
    geom_label(data = survivalROC_data %>% dplyr::select(t,auc) %>% unique,
               mapping = aes(label = sprintf("%.3f", auc)), x = 0.5, y = 0.5) +
    facet_wrap( ~ t) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
          legend.key = element_blank(),
          plot.title = element_text(hjust = 0.5),
          strip.background = element_blank())
}
```

## Incident case/dynamic control ROC

```{r}
# fonte: https://datascienceplus.com/time-dependent-roc-for-survival-prediction-models-in-r/
# The incident sensitivity considers those who die at time t
# The dynamic specificity regards those who are still alive at time t 
# This one gives the prediction performance for the hazard (incidence in the risk set) of events at t-year among those who are in the risk set at t.

IncidentCaseDynamicControlROC <- function(survival_data, survival_probabilities) {
  
  ## Define a helper function to evaluate at various t
  risksetROC_helper <- function(t) {
    risksetROC(Stime        = survival_data$days,
               status       = survival_data$vital_status,
               marker       = survival_probabilities,
               predict.time = t,
               method       = "Cox",
               plot         = FALSE)
  }
  ## Evaluate every 180 days
  risksetROC_data <- data_frame(t = ceiling(max(survival_data$days)/6) * c(1,2,3,4,5,6)) %>%
    mutate(risksetROC = map(t, risksetROC_helper),
           ## Extract scalar AUC
           auc = map_dbl(risksetROC, magrittr::extract2, "AUC"),
           ## Put cut off dependent values in a data_frame
           df_risksetROC = map(risksetROC, function(obj) {
             ## marker column is too short!
             marker <- c(-Inf, obj[["marker"]], Inf)
             bind_cols(data_frame(marker = marker),
                       as_data_frame(obj[c("TP","FP")]))
           })) %>%
    dplyr::select(-risksetROC) %>%
    unnest() %>%
    arrange(t, FP, TP)
  ## Plot
  risksetROC_data %>%
    ggplot(mapping = aes(x = FP, y = TP)) +
    geom_point() +
    geom_line() +
    geom_label(data = risksetROC_data %>% dplyr::select(t,auc) %>% unique,
               mapping = aes(label = sprintf("%.3f", auc)), x = 0.5, y = 0.5) +
    facet_wrap( ~ t) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
          legend.key = element_blank(),
          plot.title = element_text(hjust = 0.5),
          strip.background = element_blank())
}
```



## TCox functions

```{r}
twiner_glmnet <- function (x,y,alpha, w) {
                      cv.glmnet(as.matrix(x),as.matrix(y), 
                               family = 'cox',foldid = my_foldid, penalty.factor = w, 
                               alpha = alpha,
                               nlambda = 100,
                               #lambda.min.ratio = 10^(-2),
                               nfolds= 10)
}

twiner_coefs <- function (cv.fit){
  coef(cv.fit, s = 'lambda.min')[,1] %>% { .[. != 0]}
}


twiner_genes <- function (cv.fit) {
  b <- which(cv.fit$glmnet.fit$beta[,which(cv.fit$cvm == min(cv.fit$cvm))] != 0)
  return (names(b))
}

```



# Download data

```{r results = 'hide', message=FALSE, warning=FALSE}

query_RNA <- GDCquery(
  project = c("TCGA-GBM", "TCGA-LGG"),
  data.category = "Transcriptome Profiling",
  data.type = "Gene Expression Quantification",
  workflow.type = "STAR - Counts",
  experimental.strategy = ("RNA-Seq")
)
# Check if files exist before downloading
if (!dir.exists("GDCdata")) {
  GDCdownload(query = query_RNA)
}

TCGA_RNA <- GDCprepare(query = query_RNA)
```

# Prepare survival data

```{r}
# Extract survival data of interest
columns_to_extract <- c("patient", "project_id", "vital_status", "days_to_death", "days_to_last_follow_up")
survival_data <- createSurvivalDataFrame(columns_to_extract, TCGA_RNA)


# Clean and prepare survival data
survival_data <- cleanSurvivalData(survival_data)
```


# Prepare expression data

```{r}
# Extrair dataframe com a expressão dos genes de interesse
#genes_expression <- createGeneExpressionDataframe("protein_coding", "unstranded", TCGA_RNA, survival_data)
#genes_expression <- createGeneExpressionDataframe("lncRNA", "unstranded", TCGA_RNA, survival_data) 
genes_expression <- createGeneExpressionDataframe("miRNA", "unstranded", TCGA_RNA, survival_data)       #<------------ indicar os dados 

# Clean the gene expression dataframe
genes_expression <- cleanGeneExpressionData(genes_expression)
```

# Disease selection and data normalization

```{r}
# selecionar apenas os dados da doença de interesse
data_GBM <- selectDataPerDisease("TCGA-GBM", genes_expression, survival_data)
data_LGG <- selectDataPerDisease("TCGA-LGG", genes_expression, survival_data)                                   
genes_expression_GBM <- data_GBM$genes_expression
survival_data_GBM <- data_GBM$survival_data

genes_expression_LGG <- data_LGG$genes_expression
survival_data_LGG <- data_LGG$survival_data

# remove genes where the sum of the gene expression is 0 (necessary to repeat this step, since there is a selection of patients) 
genes_expression_GBM <- cleanGeneExpressionData(genes_expression_GBM)
genes_expression_LGG <- cleanGeneExpressionData(genes_expression_LGG)

# keep only columns commom to both diseases
common_columns <- intersect(names(genes_expression_GBM), names(genes_expression_LGG))
genes_expression_GBM <- genes_expression_GBM[, common_columns, drop = FALSE]
genes_expression_LGG <- genes_expression_LGG[, common_columns, drop = FALSE]

# EdgeR+voom normalization
n_rows_GBM <- nrow(genes_expression_GBM)
n_rows_LGG <- nrow(genes_expression_LGG)

genes_expression <- rbind(genes_expression_GBM, genes_expression_LGG)
genes_expression <- normalizationEdgeR(genes_expression)

genes_expression_GBM <- genes_expression[1:n_rows_GBM, ]
genes_expression_LGG <-genes_expression[(n_rows_GBM + 1):(n_rows_GBM + n_rows_LGG), ]

# Clean the gene expression dataframe
genes_expression_GBM <- cleanGeneExpressionData(genes_expression_GBM)
genes_expression_LGG <- cleanGeneExpressionData(genes_expression_LGG)

# ordenar os dados por paciente
genes_expression_GBM <- orderDataByPatient(genes_expression_GBM)
survival_data_GBM <- orderDataByPatient(survival_data_GBM)

genes_expression_LGG <- orderDataByPatient(genes_expression_LGG)
survival_data_LGG <- orderDataByPatient(survival_data_LGG)

# merge the data
genes_expression <- rbind(genes_expression_GBM, genes_expression_LGG)
survival_data <- rbind(survival_data_GBM ,survival_data_LGG)
```

# Split the data in train and test and define survival object

```{r}
# Split the data in train and test
set.seed(1012)
splited <- splitTestAndTrain(genes_expression, survival_data, 0.7)
#splited <- splitTestAndTrain(genes_expression_GBM, survival_data_GBM, 0.7)
#splited <- splitTestAndTrain(genes_expression_LGG, survival_data_LGG, 0.7)

genes_expression_train <- splited$expression_train
survival_train <- splited$survival_train
genes_expression_test <- splited$expression_test
survival_test <- splited$survival_test

# Define survival object
survival_object <- Surv(time = survival_train$days, event = survival_train$vital_status)
```

# TCox experience:
```{r}
## correlation matrices
library("propagate")
library("lsa")

options(fftempdir = "~/")


genes_expression_GBM_without_patient <- subset(genes_expression_GBM, select = -patient)
genes_expression_LGG_without_patient <- subset(genes_expression_LGG, select = -patient)

GBM_cor <- bigcor(genes_expression_GBM_without_patient, y = NULL, fun = "cor", size = 2000, verbose=FALSE)
GBM_cor <- as.data.frame(as.ffdf(GBM_cor))

LGG_cor <- bigcor(genes_expression_LGG_without_patient, y = NULL, fun = "cor", size = 2000, verbose=FALSE)
LGG_cor <- as.data.frame(as.ffdf(LGG_cor))

## angular distance
ang_weight <- vector()

for (i in 1:dim(genes_expression_GBM_without_patient)[2]){
ang_weight[i] <- acos(cosine(GBM_cor[,i],LGG_cor[,i]))/pi
}

## normalized weights (between 0 and 1)

GBM_LGG_weights <- ang_weight / max(ang_weight)
hist(ang_weight)
GBM_LGG_weights <- (1 - GBM_LGG_weights)^3
hist(GBM_LGG_weights, main="(1 - normal weight)^3")
# GBM_LGG_weights <- (GBM_LGG_weights)^3
# hist(GBM_LGG_weights, main="(normal weight)^3")

#glmnet

##Foldid
my_foldid <- sample(1:10,size=dim(survival_object)[1],replace=TRUE)
set.seed(1012)
cv.fit_tweleele3 <- twiner_glmnet(prepareDataForCoxRegression(genes_expression_train),
                                  survival_object,0.3, GBM_LGG_weights)
##genes
coefs.v_tweleele3 <- twiner_coefs(cv.fit_tweleele3)

fit.selected_tweleele3 <- twiner_genes(cv.fit_tweleele3)
length(fit.selected_tweleele3)

## Fit a Cox regression model using the covariates
fit_TCox <- coxph(survival_object ~ .,
             data = subset(genes_expression_train, select = fit.selected_tweleele3), # specify coefficients
             init = as.numeric(coefs.v_tweleele3), # specify coefficient values
             iter.max = 0) # force the software to keep those values

# Test the proportional hazards assumption for a Cox regression model fit (coxph)
Propo_hazards <- cox.zph(fit_TCox, transform="km", terms=TRUE, singledf=FALSE, global=TRUE)
Propo_hazards_global_p_value <- Propo_hazards$table["GLOBAL", "p"]

## Construct a risk score based on the linear predictor on the test data
survival_probabilities_test <- predict(fit_TCox, newdata = subset(genes_expression_test, select = fit.selected_tweleele3), type = "lp")

risk_groups <- ifelse(survival_probabilities_test > median(survival_probabilities_test), "High", "Low")

## Kaplan-Meier com a separação por High/ Low
fit_surv_TCox <- survfit(Surv(survival_test$days, survival_test$vital_status) ~ risk_groups)
survdiff(Surv(survival_test$days, survival_test$vital_status) ~ risk_groups)
ggsurvplot(fit_surv_TCox, data = survival_test)
```
